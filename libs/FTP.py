#!/usr/bin/env pythonfrom pyftpdlib.handlers import FTPHandlerfrom pyftpdlib.authorizers import DummyAuthorizerfrom pyftpdlib.servers import FTPServerfrom conf import configimport timeimport datetimeimport csvfrom libs import apiimport osimport threadingapi.log_requests = Truedef saveLastSensorSet():    try:        with open(config.storeConf,'w') as cf:            for i in range(1, len(config.sensors_st), 1):                line = "%s,%s,%s\n" % (config.fileHeader['sname%d'%i], config.fileHeader['sunit%d'%i], config.fileHeader['rawPos%d'%i])                cf.write(line)    except IOError as e:        config.log.add("ERROR: Can't [STORE] f[HEADER] %s" % e)def readDFHeader(filename):    try:        with open(filename, 'r') as db:            line = db.readline()            if (line.find("[BOF]") > -1):                if (line.find("[BOH]")):                    config.log.add("INFO: HEADER Found!")                    while (line.find("[EOH]")):                        if (line.find("Station.Parameters.Count =") > -1):                            scount = int(line[len("Station.Parameters.Count") + 3:])                            rs = 1                            config.sensors_st = {}                            while (rs <= scount):                                vName = db.readline()                                vUnit = db.readline()                                vPos = db.readline()                                vName = vName[                                        len("Station.Parameters(%s).Name =\"" % rs):-(len(vName) - vName.find(";"))]                                vUnit = vUnit[len("Station.Parameters(%s).Unit =\"" % rs):-2]                                vPos = vPos[len("Station.Parameters(%s).Position = " % rs):-1]                                config.log.add("* [%s] %s (%s)" % (vPos, vName, vUnit))                                config.fileHeader.update(                                    {'sname%s' % rs: vName, 'sunit%s' % rs: vUnit, 'rawPos%s' % rs: rs + 1})                                config.sensors_st[vName] = config.sensor_online                                rs += 1                        line = db.readline()    except Exception as e:        config.log.add("ERROR: [%s] Can't read %s" % (e, filename))    finally:        db.close()        saveLastSensorSet()def searchSensorData(dHeader, filename):    flines = "NaN"    l = " "    try:        with open(filename, 'r') as f:            l = f.readline()            while (l.find("[EOD]") < 0):                flines += l                l = f.readline()            config.log.add("INFO: Successful read[DATA] from : \"%s\"" % filename.split(config.folderSeparator)[                len(filename.split(config.folderSeparator)) - 1])    except Exception as e:        config.log.add("ERROR: Can't read[DATA] form  :[%s] \"%s\"" % (filename, e))    finally:        f.close()    fline = flines[flines.find("[BOD]") + len("[BOD]") + 2:-2]    embCSV = csv.reader(fline.split('\n'), delimiter=',')    datapack = {}    dnow = datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%dT%H:%M:%S-03:00')    rw = {'hora': datetime.datetime.fromtimestamp(time.time()).strftime('%H:%M'),          'dia': datetime.datetime.fromtimestamp(time.time()).strftime('%Y%m%d')}    for row in embCSV:        if row[0].find(rw['hora']) and row[1].find(rw['dia']):            for i in range(1, len(dHeader) / 3):                dt = dHeader['sname%d' % i].replace(" ", "") if config.sensors_st[dHeader['sname%d' % i]] == config.sensor_online else dHeader['sname%d' % i].replace(" ", "") +"_CAL"                vp = int(dHeader['rawPos%d' % i])                datapack['id%d' % i] = config.sensorId                datapack['date%d' % i] = dnow                datapack['datatype%d' % i] = dt.upper()                datapack['data%d' % i] = float(config.sensorFailure if row[vp] == '' or row[vp] == ' ' else row[vp])    config.log.add(str(datapack))    if len(datapack) > 0:        config.log.add("INFO: Pushing [DATA] to API")        try:            api.Data.dynamic_create(datapack)            config.log.add("INFO: push OK")        except Exception as e:            config.log.add("ERROR: Can't push new data.\n API says: \"%s\"" % e)    else:        config.log.add("ERROR: No new data in \"%s\"" % filename.split(config.folderSeparator)[            len(filename.split(config.folderSeparator)) - 1])    config.log.add("INFO: DEL FTP FILE: [%s]" % filename)    if(os.path.exists(filename)):        try:            os.remove(filename)        except Exception as e:            pass    lf = config.unitechFolder+config.folderSeparator+filename.split(config.folderSeparator)[len(filename.split(config.folderSeparator))-1]    config.log.add("INFO: DEL LOCAL FILE: [%s]" % lf)    if(os.path.exists(lf)):        try:            lf = config.unitechFolder+config.folderSeparator+filename.split(config.folderSeparator)[len(filename.split(config.folderSeparator))-1]            config.log.add("INFO: DEL LOCAL FILE: [%s]" % lf)            os.remove(lf)        except Exception as e:            passdef asyncLoad(nFName):    if (nFName.find("_TMP") > -1):        tmpName = nFName[:-len("_TMP")]        config.log.add("INFO: Waiting for file[%s] " % tmpName.split(config.folderSeparator)[            len(tmpName.split(config.folderSeparator)) - 1])        while (os.path.exists(tmpName) == False):            time.sleep(1)        nFName = nFName[:-len("_TMP")]        config.log.add("INFO: file[%s] Ok " % tmpName.split(config.folderSeparator)[            len(tmpName.split(config.folderSeparator)) - 1])    rfn = config.ftpRootFolder + "/" + datetime.datetime.fromtimestamp(time.time()).strftime(config.dataFileNameFormat)    config.log.add("INFO: DataFile Format OK")    if (len(config.fileHeader) == 0):        readDFHeader(nFName)    rnow = datetime.datetime.fromtimestamp(time.time()).strftime('%H:%M')    searchSensorData(config.fileHeader, nFName)class callbacks(FTPHandler):    def on_login(self, username):        config.validUser = username == config.ftpUser        config.log.add("INFO: Welcome: \"%s\" " % username)    def on_incomplete_file_received(self, file):        pass    def on_file_received(self, file):        thread = threading.Thread(target=asyncLoad, args=(str(file),))        thread.start()handler = callbacksserver =server = FTPServer((config.ftpHost, config.ftpPort), handler)def createAndRun():    resp = False    try:        config.log.add("INFO: Starting FTP Server at: %s:%s" % (config.ftpHost, config.ftpPort))        authorizer = DummyAuthorizer()        authorizer.add_user(config.ftpUser, config.ftpPass, config.ftpRootFolder, perm="elradfmw")        authorizer.add_anonymous(config.ftpGuessFolder)        handler.authorizer = authorizer        try:            resp = True            server.serve_forever()        except Exception as e:            config.log.add("ERROR: %e" % e)    except Exception as e:        config.log.add("ERROR: Can't create FTP Server...")        config.log.add(str(e))    return resp